#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>

typedef struct {
    int recursive;  // -R
    int long_format;// -l
    int show_group; // -g
} Flags;

void parse_args(int argc, char *argv[], Flags *flags, char ***targets, int *target_count) {
    flags->recursive = 0;
    flags->long_format = 0;
    flags->show_group = 0;
    *target_count = 0;
    
    *targets = malloc(argc * sizeof(char*));
    
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            for (int j = 1; argv[i][j] != '\0'; j++) {    //Пробегаемся и  расставляем флаги
                switch (argv[i][j]) {
                    case 'R':
                        flags->recursive = 1;
                        break;
                    case 'l':
                        flags->long_format = 1;
                        break;
                    case 'g':
                        flags->show_group = 1;
                        break;
                    default:
                        fprintf(stderr, "Неизвестный флаг: -%c\n", argv[i][j]);
                        break;
                }
            }
        } else {
            (*targets)[(*target_count)++] = argv[i];
        }
    }

    if (*target_count == 0) {
        (*targets)[0] = ".";
        *target_count = 1;
    }
}

void str_mode(mode_t mode, char *str) {
    if (S_ISDIR(mode)) str[0] = 'd';
    else if (S_ISCHR(mode)) str[0] = 'c';
    else if (S_ISBLK(mode)) str[0] = 'b';   // режим файла
    else if (S_ISFIFO(mode)) str[0] = 'p';
    else if (S_ISLNK(mode)) str[0] = 'l';
    else if (S_ISSOCK(mode)) str[0] = 's';
    else str[0] = '-';
    
    str[1] = (mode & S_IRUSR) ? 'r' : '-';
    str[2] = (mode & S_IWUSR) ? 'w' : '-';   //пользователь
    str[3] = (mode & S_IXUSR) ? 'x' : '-'; 
    
    str[4] = (mode & S_IRGRP) ? 'r' : '-';
    str[5] = (mode & S_IWGRP) ? 'w' : '-';  // группа
    str[6] = (mode & S_IXGRP) ? 'x' : '-';
    
    str[7] = (mode & S_IROTH) ? 'r' : '-';
    str[8] = (mode & S_IWOTH) ? 'w' : '-'; //другие
    str[9] = (mode & S_IXOTH) ? 'x' : '-';
    
    str[10] = '\0';
}

void process_symlink(const char *path, const char *name) {
    char t1[1024];
    signed long len = readlink(path, t1, sizeof(t1) - 1); // path в t1
    
    if (len != -1) {
        t1[len] = '\0'; //оканчиваем строку
        
        struct stat target;
        if (lstat(t1, &target) == 0 && S_ISLNK(target.st_mode)) {  //заполняем режимы в target и проверяем на права
            char t2[1024];
            signed long len2 = readlink(t1, t2, sizeof(t2) - 1);   
            
            if (len2 != -1) {
                t2[len2] = '\0';
                printf("%s -> %s -> %s\n", name, t1, t2);  //выводим имя с ссылкой 
            } else {
                printf("%s -> %s\n", name, t1); // выводим имя 
            }
        } else {
            printf("%s -> %s\n", name, t1); 
        }
    } else {
        printf("%s\n", name);
    }
}

void print_long_format(const char *path, const char *name, struct stat *file_stat, Flags flag) {
    char mode_str[11];
    str_mode(file_stat->st_mode, mode_str); // вывод режимов
    
    struct passwd *pw = getpwuid(file_stat->st_uid);  // имя пользователя
    struct group *gr = getgrgid(file_stat->st_gid);   // имя группы
    
    char time_str[20];
    struct tm *timeinfo = localtime(&file_stat->st_mtime);   // получаем время
    strftime(time_str, sizeof(time_str), "%b %d %H:%M", timeinfo); //  переводим время в строку
    
    printf("%s %2ld", mode_str, (long)file_stat->st_nlink); // выводим права доступа и кол-во ссылок
    
    if (!flag.show_group) {  // проверка если группа
        printf(" %-8s", pw ? pw->pw_name : "?");
    } else {
        printf(" %-8s", gr ? gr->gr_name : "?");
    }
    
    printf(" %8lld", (long long)file_stat->st_size);  // вывод размера, времени и имени
    printf(" %s", time_str);
    printf(" %s", name);
    
    if (S_ISLNK(file_stat->st_mode)) {  //проверка если ссылка символическая
        char link_target[1024];
        signed long len = readlink(path, link_target, sizeof(link_target) - 1);
        if (len != -1) {
            link_target[len] = '\0';
            printf(" -> %s", link_target);
        }
    }
    
    printf("\n");
}

void process_entry(const char *path, const char *name, Flags flags, int is_dir) {  
    struct stat file_stat;
    char full_path[1024];
    
    if (strcmp(path, ".") == 0) { //текущий ли каталог?
        snprintf(full_path, sizeof(full_path), "%s", name);    
    } else {     // записываем полный путь в full_path
        snprintf(full_path, sizeof(full_path), "%s/%s", path, name);
    }
    
    if (lstat(full_path, &file_stat) == -1) {  //  
        perror("lstat");
        return;
    }
    
    if (flags.long_format) {  // проверка флага
        print_long_format(full_path, name, &file_stat, flags); 
    } else {
        if (S_ISLNK(file_stat.st_mode)) {
            process_symlink(full_path, name);
        } else {
            printf("%s\n", name);
        }
    }
}

void process_directory(const char *path, Flags flags, int recursive_call) {
    DIR *dir;
    struct dirent *entry;
    
    if ((dir = opendir(path)) == NULL) {
        perror("opendir");
        return;
    }
    
    if (recursive_call) {
        printf("\n%s:\n", path);
    }
    
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_name[0] == '.' && !flags.long_format) { 
            continue;
        }
        
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        
        process_entry(path, entry->d_name, flags, 0);
    }
    
    if (flags.recursive) {
        rewinddir(dir);
        dir = opendir(path);
        
        while ((entry = readdir(dir)) != NULL) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
                continue;
            }
            
            char full_path[1024];
            snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
            
            struct stat file_stat;
            if (lstat(full_path, &file_stat) == 0 && S_ISDIR(file_stat.st_mode)) {
                process_directory(full_path, flags, 1);
            }
        }
        
        closedir(dir);
    }
}

int main(int argc, char *argv[]) {
    Flags flags;
    char **targets;
    int target_count;
    
    parse_args(argc, argv, &flags, &targets, &target_count);
    
    for (int i = 0; i < target_count; i++) {
        struct stat path_stat;
        
        if (stat(targets[i], &path_stat) == -1) {
            perror("stat");
            continue;
        }
        
        if (S_ISDIR(path_stat.st_mode)) {
            if (target_count > 1) {
                printf("%s:\n", targets[i]);
            }
            process_directory(targets[i], flags, 0);
            
            if (i < target_count - 1) {
                printf("\n");
            }
        } else {
            process_entry(".", targets[i], flags, 0);
        }
    }
    
    free(targets);
    
    return 0;
}
